---
title: '가장 강력한 머신 러닝 모델 설명 (Transformers, CNNs, RNNs, GANs 등)'
categories:
  - Programming
  - AI
tags:
  - Programming
  - AI
  - Artificial Intelligence
  - Data Science
  - Machine Learning
  - Software Development
  - ChatGPT
date: 2024-10-18 14:35:33
thumbnail: /images/thumbnail/ai.png
---

![](/images/header/ai-27.png)

머신 러닝은 방대한 분야이며, 현재 기술의 최전선에 있는 모델과 기법들을 개괄적으로 다룬 자료를 찾는 것이 어렵게 느껴질 수 있습니다. 따라서, 이 글에서는 각 모델을 과학적으로 분석하기보다는 개념적으로 탐구해보겠습니다. 각 모델에 대해 더 깊이 파고들기를 권장하며, 이론이 실무와 연결되어야 한다고 생각하기 때문에 실제 사용 예시도 제공하겠습니다. 만약 빠진 정보가 있다면 피드백을 주시고, 추가 정보를 요청해주세요.

시작하기 전에 다룰 모델 목록은 다음과 같습니다.

- CNN (Convolutional Neural Networks)
- RNN (Recurrent Neural Networks)
- Transformers
- GAN (Generative Adversarial Networks)

## CNN (합성곱 신경망)

CNN(Convolutional Neural Network, 합성곱 신경망)은 신경망의 한 종류로, 토폴로지 데이터(위상적 데이터)에 뛰어나며 패턴 감지에 특화되도록 수정된 모델입니다. 그렇다면 CNN은 어떻게 다를까요? 시작하기 전에, 신경망이 무엇인지 간단히 설명해 드리겠습니다.

간단히 말해, 신경망은 입력 데이터를 처리하여 출력을 생성하는 "노드의 맵"입니다. 신경망은 입력을 결과로 변환하면서 한 레이어의 노드 집합을 다른 레이어의 노드 집합으로 매핑하는 여러 레이어로 구성되어 있습니다. 이 매핑 과정은 가중치(weights)를 통해 이루어지며, 이는 입력을 변경하여 원하는 결과를 도출하는 데 사용됩니다. 각 단계 후에는 편향(bias)이 적용됩니다. 학습 과정에서 변경되는 것은 바로 이 가중치와 편향입니다.

![](/images/header/ai-27_1.png)

### CNN의 특별한 점은 무엇일까요?

CNN을 다른 신경망과 구분 짓는 것은 바로 **합성곱 레이어**(convolutional layers)를 사용하는 점입니다. CNN은 다른 유형의 레이어도 가질 수 있지만, 합성곱이 그만의 독특함을 부여합니다. 다음은 이 레이어가 어떻게 작동하는지 설명입니다.

이미지의 각 픽셀이 밝기 값이라고 가정하면, 이미지는 2차원 숫자 행렬로 표현될 수 있습니다. 합성곱은 이 행렬에 커널(kernel)을 적용하여 출력 행렬을 생성합니다. 커널은 이미지의 각 영역에 필터처럼 작용하는 작은 행렬입니다.

이 작은 커널 행렬은 이미지라는 큰 행렬을 "Steps"하며 출력 행렬을 생성합니다.

![](/images/header/ai-27_2.gif)

### 주요 개념

몇 가지 중요한 개념은 다음과 같습니다.

- 커널은 이미지의 각 픽셀과 그 주변 영역에 적용되지만, 전체적으로 동일하게 유지됩니다. 이는 커널이 해당 픽셀 영역의 패턴이나 특징을 감지하기 위한 것이기 때문입니다.
- 커널은 이미지보다 훨씬 작기 때문에 학습 과정에서 큰 도움이 됩니다.
- 커널의 아이디어는 어떤 이미지든 우리가 분해할 수 있는 패턴들의 집합이라는 점에 기반합니다. 예를 들어, 얼굴을 가지고 있다고 가정해봅시다. 동그라미를 감지할 수 있는 커널이 있다고 할 때, 이 커널의 출력은 이미지 상단 부분(눈 부분)에 두 개의 밝은 점을 생성할 수 있습니다. 이제 가까운 두 개의 선을 감지하는 커널을 사용하면, 출력은 하단 부분(입 부분)에 밝은 점을 생성합니다. 마지막으로, 이러한 두 개의 동그라미와 하단의 두 선을 감지할 수 있는 커널이 있다면, 이는 얼굴을 인식할 수 있게 됩니다.
- 합성곱 레이어는 이러한 커널을 여러 개 적용하여 여러 개의 새로운 이미지를 생성할 수 있습니다. 이러한 이미지는 네트워크에서 다음 레이어로 전달되며, 이후 또 다른 합성곱 레이어가 다른 커널을 적용합니다.
- CNN은 보통 이미지의 크기와 복잡성을 줄이기 위해 풀링 레이어(**pooling** layers)를 포함합니다.

물론, 여기에는 더 많은 수학적 상세 정보가 있지만, CNN의 주요 직관은 **커널**에 있습니다.

CNN을 사용하는 인기 있는 도구와 제품으로는 Google Photos, DeepMind의 AlphaGo, Tesla의 자율주행 시스템 등이 있습니다.

## RNN (순환 신경망)

CNN이 주로 이미지 처리에 사용되는 반면, RNN은 주로 자연어 처리(NLP)와 시계열 분석과 같은 분야에 사용됩니다. RNN의 아키텍처를 이해하려면, 먼저 NLP 문제에서 단순한 신경망을 사용하는 데 있어서의 문제점을 살펴보겠습니다.

예를 들어, 텍스트 자동 완성 문제를 생각해 봅시다. 모델의 입력은 텍스트 조각이고, 출력 역시 또 다른 텍스트 조각입니다. 문제는 입력이 **가변적인 크기**(몇 단어일 수도 있고 많은 단어일 수도 있음)라는 점입니다. 단순 신경망은 일반적으로 **고정된 입력 크기**를 가지기 때문에 이러한 문제를 처리하기 어렵습니다. 또 다른 문제는 입력 내 단어들 간의 복잡한 관계를 포착하여 올바른 출력을 생성하는 것입니다. 예를 들어, 영어에는 수천 개의 단어가 있으며, 문장에서 단어의 순서가 의미를 크게 변경하지 않을 수 있습니다. 예를 들어, "The fluffy cat came here on Sunday"와 "On Sunday, the cat which was fluffy came here"는 유사한 의미를 가지지만, "The Sunday came here on a fluffy cat"은 다른 의미를 가집니다. 그렇다면 어떻게 이러한 문장이 유사하게 처리되도록 할까요?

RNN의 핵심 개념은 정보가 네트워크를 통과하는 방식에서 비롯됩니다. 예를 들어, "The cat eats"라는 문장을 RNN이 어떻게 처리하는지 살펴봅시다.

문장을 "The", "cat", "eats"와 같은 단어들의 시퀀스로 생각해 봅시다(실제로는 숫자나 벡터의 시퀀스로 표현될 것입니다). RNN은 이 시퀀스를 순차적으로 처리합니다. 먼저, 단어 "The"를 입력으로 받아 가중치와 편향을 통해 x1이라는 출력을 생성합니다. 그 다음, RNN은 x1과 시퀀스의 다음 단어인 "cat"을 받아, 같은 가중치와 편향을 통해 x2를 생성합니다. 이후, x2와 다음 단어인 "eats"를 사용하여 x3을 생성합니다. 이와 같은 방식으로, RNN은 이전 출력과 다음 입력을 결합하여 새로운 출력을 생성합니다. RNN의 현재 상태를 은닉 상태(**hidden state**)라고 부릅니다.

![](/images/header/ai-27_3.gif)

### 어떻게 RNN을 사용해 다음 단어를 예측할 수 있을까요?

각 출력(x1, x2, x3)이 실제로 새로운 단어를 나타낸다고 가정해 보세요. 모델을 학습시켜 출력이 실제로 다음 단어를 예측하도록 할 수 있습니다. 예를 들어, 다음과 같이 문장을 처리한다고 해봅시다.

1. "The" -> 모델을 통과 -> x0 생성, x0이 "cat"으로 올바르게 예측되도록 모델을 학습시킵니다.
2. "cat"과 이전 출력 x0 -> 모델을 통과 -> x1 생성, x1이 "eats"로 올바르게 예측되도록 학습합니다.
3. "eats"와 이전 출력 x1 -> 모델을 통과 -> x2 생성. 이때, x2가 "tuna"라는 단어를 나타내도록 학습됩니다. 이제 이를 다음 입력으로 사용할 수 있습니다.
4. "tuna"와 이전 출력 x2 -> 모델을 통과 -> x3 생성… 이와 같은 방식으로 계속 진행됩니다.

### 주요 개념

RNN의 주요 개념은 다음과 같습니다.

- RNN은 은닉 상태를 통해 이전에 본 정보를 항상 추적할 수 있으며, 이는 단어들 간의 관계나 일련의 데이터를 포착하는 데 유용합니다.
- **동일한 모델**이 시퀀스의 각 부분에 반복적으로 적용되기 때문에, RNN은 학습하기에 적합합니다(거대한 모델로 전체 입력을 한꺼번에 처리하는 것보다 효율적임).

하지만 이 접근 방식의 문제점도 이미 예상할 수 있습니다. 텍스트가 길어질수록 초기의 몇 단어가 현재의 은닉 상태에 거의 영향을 미치지 못해 이상적이지 않습니다. 또한, 이 방식은 순차적으로 처리해야 하므로, 처리 속도와 학습 속도가 알고리즘 자체에 의해 제한됩니다.

여전히 RNN은 매우 강력한 모델이며, 더 깊게 탐구해 볼 것을 권장합니다!

RNN을 사용하는 대표적인 도구와 제품으로는 Google 번역, OpenAI의 GPT-2, Spotify의 추천 시스템 등이 있습니다.

## Transformer (트랜스포머)

트랜스포머! 현재 머신 러닝 세계에서 가장 주목받고 있는 기술입니다. GPT-4와 BERT(구글의 고급 언어 모델) 모두 트랜스포머 아키텍처를 기반으로 하고 있습니다. 그렇다면 트랜스포머란 무엇일까요?

트랜스포머는 RNN처럼 주로 NLP 문제를 해결하는 데 사용되며, 앞서 설명한 언어 처리와 관련된 유사한 문제들을 해결해야 합니다. 그러나, RNN과는 다르게 이러한 문제들을 해결하기 위한 몇 가지 주요한 아이디어를 가지고 있습니다.

- **위치 인코딩(Positional Encoding)** — RNN은 은닉 상태를 통해 자연스럽게 언어의 순서를 유지하지만, 트랜스포머는 이 정보를 입력에 직접적으로 추가합니다. 위치 인코딩이 단어 임베딩(단어의 벡터 표현)에 더해져, 문장 내 각 단어의 위치를 파악할 수 있도록 합니다. 예를 들어, "dog"의 표현은 텍스트 내 위치에 따라 다르게 조정됩니다.
- **대규모 학습 데이터셋(Huge training dataset size)** — 위치 인코딩의 이점을 활용하기 위해, 트랜스포머는 방대한 데이터셋을 통해 학습해야 합니다. 이러한 순서의 차이와 단어 유형은 데이터에 반영되기 때문에, 다양한 가능성을 충분히 학습하지 않으면 모델의 성능이 떨어집니다.
- **자기 주의(Self-attention)** — 모델은 입력에서 특정 단어들과 다른 모든 단어들 간의 관계를 더 중요하게 여기는 법을 학습합니다. 결국, 어떤 단어들은 예측이나 번역에서 더 많은 의미를 가지고 있으며, 다른 단어들과 함께 사용될 때 더 강한 힘을 발휘합니다. 트랜스포머는 이를 대규모 학습 데이터와 자체적인 아키텍처를 통해 학습합니다.

트랜스포머의 아키텍처는 다소 복잡하며, 짧은 글에서 설명하기 어렵지만, 여기서 간단하게 개략적인 설명을 드리겠습니다. 트랜스포머는 **인코더**(Encoder)와 **디코더**(Decoder)로 구성됩니다. 인코더는 동일한 레이어들의 스택으로 이루어져 있으며, 텍스트를 처리하여 디코더에 필요한 중요한 정보를 제공합니다. 디코더는 이 입력을 받아, 동일한 레이어 스택을 통해 우리가 원하는 출력을 생성하는 역할을 합니다. 아래 그림은 이 아키텍처를 보여주는 이미지입니다.

![](/images/header/ai-27_4.png)

특히 트랜스포머의 핵심인 "자기 주의(Self-attention)" 메커니즘에 대해 깊이 공부해 보시기를 추천드립니다.

## GAN (생산적 적대 신경망)

GANs(Generative Adversarial Networks, 생성적 적대 신경망)은 기본적으로 두 개의 대립하는 모델이 서로 경쟁하는 구조입니다. GAN은 보통 이러한 모델들을 학습시키는 방법을 가리키며, 모델 자체보다는 학습 방식에 초점을 맞춥니다. 사실, 두 모델의 아키텍처가 중요한 것은 아니며, 하나는 생성 모델(Generative Model)이고 다른 하나는 판별 모델(Classifier, 또는 Discriminator)이기만 하면 됩니다.

먼저, 표준적인 지도 학습 기법을 설명해 보겠습니다.

- 모델에 입력 데이터를 제공하고, 모델이 출력을 생성합니다.
- 이 출력과 원하는 출력(정답)을 비교하여, 모델이 더 나은 결과를 내도록 업데이트합니다.

그러나 우리가 생성 모델을 만들고자 할 때 문제가 발생합니다. 이 모델은 현실적인 출력을 생성해야 하지만, 그 출력이 꼭 우리가 가지고 있는 데이터와 동일할 필요는 없습니다(예: 이미지 생성 또는 음악 생성). 바로 이때 GAN이 유용하게 쓰입니다. GAN에는 두 개의 모델이 있는데, 생성자(Generator) 모델과 판별자(Discriminator) 모델입니다.

**예시를 들어 설명해 보겠습니다.**

생성자 모델이 이미지를 생성한다고 가정해 봅시다. 먼저 이 모델을 이용해 여러 개의 가짜 이미지를 생성하도록 합니다. 그리고 실제 이미지를 몇 개 찾아서 이 가짜 이미지들과 결합합니다. 그런 다음, 이 이미지들을 판별자 모델에 입력하여 진짜인지 가짜인지를 구분하게 합니다. 만약 생성자 모델이 잘 작동한다면, 판별자 모델은 진짜와 가짜를 구분하기 어려워할 것이며, 진짜인지 가짜인지 맞출 확률이 약 50%에 가까워집니다. 당연히 초기에는 판별자가 더 잘 구분합니다(판별자는 보통 사전 학습이 약간 되어 있음). 따라서, 지도 학습 방식으로(우리 스스로 어떤 이미지가 진짜인지 가짜인지 알고 있기 때문에) 판별자 모델을 더 잘 학습시키게 됩니다. 또한, 생성자 모델도 판별자를 얼마나 잘 속였는지에 따라 학습할 수 있습니다. 학습은 생성자 모델이 판별자를 약 50% 확률로 속일 수 있을 때 완료됩니다.

![](/images/header/ai-27_5.png)

GAN이 실제로 사용되는 몇 가지 예로는 Runway ML, Midjourney의 아트 생성, OpenAI의 DALL·E가 있습니다.
